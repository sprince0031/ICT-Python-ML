[Slide 1 - Intro]
Hey everyone, and welcome to the second video of week 2 in the Python and ML Foundations series! In this video, we are tackling a cornerstone of programming: loops.

[Slide 2 - Loops]
Before we dive into the 'what', let's talk about the 'why'. In programming, we have a core philosophy called D.R.Y. i.e., Don't Repeat Yourself. That's right, we like to see you being lazy but smart. Imagine you had to write 100 lines of code to append items from a list of data. It would be tedious and, frankly, a waste of time.

[Slide 3 - What are loops?]
This is where loops come in. A loop is a structure that executes a block of code for a defined number of iterations. It’s your own personal coding robot that handles the repetitive stuff for you.

[Slide 4 - Why use loops?]
Using them reduces duplicate code, which makes your programs shorter, easier to read, and much simpler to debug later on. This is absolutely critical as we start building more complex logic such as training loops for our machine learning models.

[Slide 5 - Implementing loops in Python: types]
In Python, we have two main kinds of loops: the for loop and the while loop. Let's start with the one you'll probably use 90% of the time: the for loop.

[Slide 6 - for loops: syntax]
A for loop is perfect for iterating over a sequence—like a list, a string, or a range of numbers. The syntax is beautifully simple. All you need to do is to type in the 'for' keyword, then a temporary variable, the 'in' keyword and then finally your data structure which is going to be your iterable. So basically your list, range, etc. Then you can do something for each step of the loop. That's it!

[Slide 7 - for loops: example]
Following up on the same example scenario of handling an admin list of allowed software from the last video, let's see how we can use loops in practice.

[Google Colab week 2 reference notebook - 2.1]
We have our defined list in this cell which we will execute. In the next cell, we'll write our for loop to iterate through every software name in the list and print each one out. Note that this is very intuitive to read. for software in the software list, we are doing some action. That's your simple for loop.

[Slide 8: for loops with range()]
What if you don't have a list, but just want to do something a specific number of times? For that, we use the built-in range() function. The input parameters i.e., values you can pass to tell range() to give you an output follows the exact same pattern you used last week with list slicing. These are the start, end and step parameters. Here's a quick recap from last week.

[Recap portion from PMLF-S1V3-Advanced Datatypes: Step parameter]
There is also a third parameter called step, which lets you skip elements. For instance, a step of 2 will grab every second element in the list. So, this should give us 1, 3, 5 and so on.

[Google Colab week 2 reference notebook - 2.1]
Let's see this in action. Now is a good time to introduce the in-built 'len()' function which returns the length of any collection datatype like a list and even a string. We see that the length of our allowed software list is 5. So we can directly call the len() function on our list within our range() function as part of our for loop statement. Now that seems like a lot, but when it comes together, you will see that it makes sense. The temporary iterable variable is 'i' here which will take the values from 0 to 4 as it updates through the loop. Again remember that the end value is exclusive. Also remember that we accessed the value of our list using the value of 'i' as the index.

[Side 9 - While loops: syntax]
Alright, let's talk about the while loop. A while loop keeps running as long as a certain condition is true. The syntax is: 'while' and then your end condition. The most important rule of while loops: you must ensure the condition eventually becomes false. If you don't, you've created an infinite loop, and your program will be stuck forever! We usually do this with a count, just like this. This can either count up or count down, as in it keeps subtracting. That really depends on the logic of what you want to do within the loop.

[Google Colab week 2 reference notebook - 2.2]
So, since this is a while loop and there is no inherent counter like in the for loop, we need to define our counter or iterative variable ourselves. For the while loop itself, we use the same 'len()' function to get our upper limit till which we want to run the loop. 'While' also uses conditions like your conditional statements from just the last video. It keeps running the loop until the defined condition becomes False. Here, we need to run it until it is less than the length of the list. This is again a callback to list indices starting from 0 which is why we only use the 'less than' operator. To reiterate, we need to take care of the counter ourselves and hence need to increment it after our loop operation to avoid it running till the computer's memory runs out. 

[Slide 10 - While loops: example]
So, when would you use this? When we already have the for loop, why would we need the while loop?

[Slide 11 - When to use while over for?]
While loops are perfect for when you don't know how many iterations you'll need. Think of downloading a file or, as shown on this slide, running a data analysis task. Now, this isn't really doing anything. It's just to simulate a progress bar here. This is useful for when you don't know exactly how many number of steps you're going to need as in you don't know a range. And all you know is a stop condition. The loop runs until the job is done. However long that takes. 

[Slide 12 - Flow control in loops]
Quickly, let's cover flow control. Sometimes you need to change a loop's behavior mid-execution. 'Break' will exit the loop immediately. 'Continue' will skip the rest of the current iteration and jump straight to the next one i.e., it will just totally ignore all the lines of code that comes after you define the continue keyword and it will go to the next. Finally, the else clause will run only if the loop finishes naturally, without a break. So, let's just go over this...

[Google Colab week 2 reference notebook - 2.1]
Let's modify our for loop code here. If we add an if statement that asks the loop to break if the value of 'i' is 2, the loop exits before the entire list can be processed as per our defined condition. The output shows python and git. When we use continue however, the loop runs to completion for the whole list. Only difference is that when 'i' was 2, it skipped executing the code below and started the next iteration. In the output, you will see that the third item, 'vscode' is missing. This is the key difference between break and continue. Finally, we add an else block after the loop. You can see that the print statement inside the else block executed but now if we change the continue to a break, it will not because the loop did not finish all iterations over the list.

[Slide 13 - Nested loops: what?]
Okay, that brings us to the final topic, nested loops. A nested loop is a loop within another loop. Just like in the movie inception where time passes differently in deeper dream levels, the inner loop has to run to completion for every single iteration of the outer loop. So too many nested loops can get your code to slow down a lot. 

[Slide 14 - Nested loops: example]
Here is an example of a nested loop continuing our theme for the week with admin software lists. We have a dictionary, 'user_alloted_software' which tracks software each user in an organisation is allowed to install. Note that there is a list associated with each user. To get a full list of the software by user, we can loop through all the users in the dictionary and for each user, loop through their list of allowed software. Now, we have a loop within a loop a.k.a, the nested loop. You can see this visualised here as the program loops through two levels of data. Note that the users correspond to the outer loop and respective software names are handled by the inner loop.

[Slide 15 - Practice question]
Now for the practice question. Create a simple loop that calculates the factorial of a given number, say 5. As it says here, a factorial is the product of all positive integers up to that number. So, 5 factorial will be 5 times 4 times 3 times 2 times 1 which would be 120. As always, this question will be there in the linked companion colab notebook.

[Slide 16 - Outro]
Thank you and see you in the next one!
